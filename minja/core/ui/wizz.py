# wizz.py

import re
import time
import email.utils

from core.data import smtp,smpls,fpr,tc,tr,DEBUG
from core.func import get_inputs,get_single_input,waitin,dbglog,get_yesno_input
from core.msg.content import att_custom_header


__all__ = [
    'run_wizzard_host',
    'run_wizzard_headers',
    'run_wizzard_dkim',
]


def run_wizzard_host(d):
# WHAT CAN BE DONE MORE: 
# - use get)single and get_yesno fun
# - modify to support multiple hosts ?

    fpr('Welcome in Wizzard')
    print 
    fpr('Please follow .. ') 
    print

    t = dict()

    t['host'] =  get_single_input('SMTP Host', d.get('host',''),nl='') 
    t['port'] =  get_single_input('SMTP Port', d.get('port',''),nl='') 
    t['helo'] =  get_single_input('SMTP HELO', d.get('helo',''),nl='')
    t['smtp_auth_user'] =  get_single_input('SMTP AUTH Username ', d.get('smtp_auth_user',''),nl='')
    t['smtp_auth_pass'] =  get_single_input('SMTP AUTH Password ', d.get('smtp_auth_pass',''),nl='')
 #   t['tls_mode']  =  get_single_input('SMTP TLS', d.get('tls_mode','NoTLS'),nl='')

    if d.get('tls_mode') == 'NoTLS': 
        fpr('TLS Mode:  Disabled')
        if get_yesno_input('    > Enable TLS mode [y/N]> '):
            t['tls_mode'] = 'TLS'
            fpr('TLS Mode:  Enabled')
         
    elif d.get('tls_mode') == 'TLS':
        fpr('TLS Mode: Enabled')
        if get_yesno_input('    > Disable TLS mode [y/N]> '):
            t['tls_mode'] = 'NoTLS'
            fpr('TLS Mode: Disabled')
    

    print
    if raw_input('  Save [Y/n]> ') in ['y', 'Y', '']:
        print
        fpr.ok('Settings saved')
        for k in t.keys():
             d[k] = t[k]
    else:
        print 
        fpr.fail('Settings not saved!')


def run_wizzard_headers():

    # RFC 822
    # https://tools.ietf.org/html/rfc822

    #import re
    #import time
    #import email.utils

    #from core.data import smtp,smpls,fpr,tc,tr,DEBUG
    #from core.func import get_inputs,get_single_input,waitin,dbglog

    # The Origination Date Field
    #  -> https://tools.ietf.org/html/rfc5322#section-3.6.1
    currentDate =  email.utils.formatdate(localtime=True)
    smtp['headers']['h_Date'] = \
        get_single_input('Date:',  currentDate, nl='') #or currentDate

    # Information Field
    #  -> https://tools.ietf.org/html/rfc5322#section-3.6.5
    smtp['headers']['h_Subject'] = \
        get_single_input('Subject: ' ,  smtp['headers'].get('h_Subject',''), nl='') #\
                                              # or smtp['headers'].get('h_Subject','')
    defaultComment = 'Message generated by %s (%s)' % ('minja-dev',time.time())
    smtp['headers']['h_Comment'] = \
        get_single_input('Commment: ' , smtp['headers'].get('h_Comment',defaultComment), nl='') #\
    # Originator Fields
    #  -> https://tools.ietf.org/html/rfc5322#section-3.6.2
    smtp['headers']['h_From'] =  \
        get_single_input('From: ' ,  smtp['headers'].get('h_From',smtp['addrlist'].get('mail_from','')), nl='') #\
    smtp['headers']['h_Sender'] = \
        get_single_input('Sender: ' ,  smtp['headers'].get('h_Sender',''), nl='') #\
    smtp['headers']['h_Reply-To'] = \
        get_single_input('Reply-To: ' ,  smtp['headers'].get('h_Reply-To',''), nl='') #\
           #  or smtp['headers'].get('h_Reply-To','')
    # Destination Address Fields
    #  ->  https://tools.ietf.org/html/rfc5322#section-3.6.3
    smtp['headers']['h_To']= \
        get_single_input('To: ' ,  smtp['headers'].get('h_To',smtp['addrlist'].get('rcpt_to','')), nl='') #\
    smtp['headers']['h_Cc'] =  \
        get_single_input('Cc: ' ,  smtp['headers'].get('h_Cc',''), nl='') #\
           #  or smtp['headers'].get('h_Cc','')
    smtp['headers']['h_Bcc'] = \
        get_single_input('Bcc: ' ,  smtp['headers'].get('h_Bcc',''), nl='') #\
           #  or smtp['headers'].get('h_Bcc','')

    # Return-Path
    smtp['headers']['h_Return-Path'] = \
        get_single_input('Return-Path: ' ,  smtp['headers'].get('h_Return-Path',''), nl='') #\
    # if raw_input('  Would you like to include extended headers [y/N]> ') in  ['y', 'Y']:
    #    fpr('Including additional headers ...')
 
    # X-Custom: attach custom headers
    print 
    att_custom_header()

    """
    if raw_input('  Would you like to include your own headers [y/N]> ') in ['y', 'Y']:
        while True:
            print
            fpr('Please provide a header in format: >> Header-name: header-value <<')
            fpr('Use Ctrl-D to continue.')
            fpr.blue('_'*(tc-4))
            print
            # to preserve new line pass nl=True with get_inputs()
            inputs = get_inputs()
            if inputs != '':
                thead = {}
                ####### TODO: move this to def encode_mheaders()
                for (i,hline) in enumerate(inputs):
                    #print hline                                        
                    m1 = re.match(r'(.*):(.*)',hline)  # it is a header 
                    m2 = re.match(r'^(\s+)(.*)',hline)  # it is a continuation of prev header
                    if hline == '\n':
                        key = ''
                    elif m1:
                         if m1.group(1):
                             key = m1.group(1)
                             thead.setdefault(key,[]).append(m1.group(2))
                    elif m2:
                        if key == '' and inputs[i-1] != '\n':
                            key = '-no-hn-'
                            while key in thead.keys():
                                key += '-'
                        thead.setdefault(key,[]).append(m2.group(1)+m2.group(2))
                #############
                fpr.blue('_'*(tc-4))
                for k in thead.keys():
                    fpr.info('_'*(tc-4)) 
                    print
                    if re.match('-no-hn-',k):
                        fpr('Header-name: <None>')
                    else:
                        fpr('Header-Name: %s' % k)
                        fpr('Header: %s' % thead[k])
                        #fpr('Encoding: %s' % enc)

                    fpr.info('_'*(tc-4)) 
                fpr.blue('_'*(tc-4))
                print
      
                #print theadi
                if thead.keys():
                    if raw_input('  Are your headers parsed correctly [Y/n]:> ') in ['n', 'N']:
                        if raw_input('  Would you like to add them one more time [Y/n]:> ') in ['n','N']:     
                            break
                        else:
                            waitin()

                    else:

# if RFC: format header-name, format header length, 
#                        rfcline = 1
#                        if raw_input('  Should lines follow the RFC or leave it as you put it [Y/n]> ') in ['n', 'N']:
#                            rfcline = 0
                        
                        ####
                        for k in thead.keys():
                            smtp['headers']["h_%s" % k ] = thead[k] 
                        ####
                        dbglog(smtp['headers']) 
                        waitin()
                        break
                else:
                    fpr('No header was specified')
                    waitin()
                    break
    """

    # clear value with dot 
    for k in smtp['headers'].keys():
        # find key for smtp headers only, these starts with 'h\d*_'
        if re.match(r'^h\d*_',k):
            if isinstance(smtp['headers'][k], basestring): 
                if re.match(r'^\.$',smtp['headers'][k]):
                    #print smtp[k] + 'it is a dot - clear it !' #DEBUG
                    smtp['headers'][k] = ''
    #print smtp 



def run_wizzard_dkim():
    pass




